## MultiRepo VS MonoRepo


<table style={{ borderCollapse: 'collapse', width: '800px' }}>
  <thead>
    <tr style={{ backgroundColor: '#f6f6f6' }}>
      <th style={{ border: '1px solid #f6f6f6', padding: '8px', textAlign: 'left', width: '120px' }}>场景</th>
      <th style={{ border: '1px solid #f6f6f6', padding: '8px', textAlign: 'left' }}>MultiRepo</th>
      <th style={{ border: '1px solid #f6f6f6', padding: '8px', textAlign: 'left' }}>MonoRepo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>代码可见性</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>✅ 代码隔离，研发者只需关注自己负责的仓库<br />❌ 包管理按照各自owner划分，当出现问题时，需要到依赖包中进行判断并解决。</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>✅ 一个仓库中多个相关项目，很容易看到整个代码库的变化趋势，更好的团队协作。<br />❌ 增加了非owner改动代码的风险</td>
    </tr>
    <tr style={{ backgroundColor: '#f6f6f6' }}>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>依赖管理</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>❌ 多个仓库都有自己的 node_modules，存在依赖重复安装情况，占用磁盘内存大。</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>✅ 多项目代码都在一个仓库中，相同版本依赖提升到顶层只安装一次，节省磁盘内存</td>
    </tr>
    <tr>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>代码权限</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>✅ 各项目单独仓库，不会出现代码被误改的情况，单个项目出现问题不会影响其他项目。</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>❌ 多个项目代码都在一个仓库中，没有项目粒度的权限管控，一个项目出问题，可能影响所有项目。</td>
    </tr>
    <tr style={{ backgroundColor: '#f6f6f6' }}>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>开发迭代</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>✅ 仓库体积小，模块划分清晰，可维护性强。<br />❌ 多仓库来回切换（编辑器及命令行），项目多的话效率很低。多仓库见存在依赖时，需要手动 `npm link`，操作繁琐。<br />❌ 依赖管理不便，多个依赖可能在多个仓库中存在不同版本，重复安装，npm link 时不同项目的依赖会存在冲突。</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>✅ 多个项目都在一个仓库中，可看到相关项目全貌，编码非常方便。<br />✅ 代码复用高，方便进行代码重构。<br />❌ 多项目在一个仓库中，代码体积多大几个 G，`git clone`时间较长。<br />✅ 依赖调试方便，依赖包迭代场景下，借助工具自动 npm link，直接使用最新版本依赖，简化了操作流程。</td>
    </tr>
    <tr>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>工程配置</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>❌ 各项目构建、打包、代码校验都各自维护，不一致时会导致代码差异或构建差异。</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>✅ 多项目在一个仓库，工程配置一致，代码质量标准及风格也很容易一致。</td>
    </tr>
    <tr style={{ backgroundColor: '#f6f6f6' }}>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>构建部署</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>❌ 多个项目间存在依赖，部署时需要手动到不同的仓库根据先后顺序去修改版本及进行部署，操作繁琐效率低。</td>
      <td style={{ border: '1px solid #f6f6f6', padding: '8px' }}>✅ 构建性 Monorepo 工具可以配置依赖项目的构建优先级，可以实现一次命令完成所有的部署。</td>
    </tr>
  </tbody>
</table>


综合如上 Monorepo VS MultiRepo，**中大型项目**，**多模块项目**，更适合用 MonoRepo 方式管理代码，在开发、协作效率、代码一致性方面都能受益。